#!/bin/bash
# Backup and restore dotfiles configurations

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../scripts/lib/utils.sh"

# Configuration
BACKUP_DIR="$HOME/.dotfiles-backups"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
MAX_BACKUPS=10

# Files to backup
BACKUP_FILES=(
    "$HOME/.zshrc"
    "$HOME/.zshenv" 
    "$HOME/.zsh_aliases"
    "$HOME/.gitconfig"
    "$HOME/.gitignore_global"
    "$HOME/.config/starship.toml"
    "$HOME/.config/nvim"
    "$HOME/.ssh/config"
    "$HOME/.tmux.conf"
)

# Create backup
create_backup() {
    local backup_name="${1:-$TIMESTAMP}"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    print_status "Creating backup: $backup_name"
    
    # Create backup directory
    mkdir -p "$backup_path"
    
    # Backup each file/directory
    for item in "${BACKUP_FILES[@]}"; do
        if [[ -e "$item" ]]; then
            local relative_path="${item#$HOME/}"
            local backup_item="$backup_path/$relative_path"
            
            # Create parent directory in backup
            mkdir -p "$(dirname "$backup_item")"
            
            # Copy file or directory
            if [[ -d "$item" ]]; then
                cp -r "$item" "$backup_item"
                print_success "Backed up directory: $relative_path"
            else
                cp "$item" "$backup_item"
                print_success "Backed up file: $relative_path"
            fi
        else
            print_warning "Skipping non-existent: ${item#$HOME/}"
        fi
    done
    
    # Create backup manifest
    cat > "$backup_path/BACKUP_INFO" << EOF
Backup created: $(date)
Hostname: $(hostname)
User: $(whoami)
Dotfiles version: $(cd "$HOME/.dotfiles" 2>/dev/null && git rev-parse HEAD || echo "unknown")
OS: $(uname -s)
Shell: $SHELL
EOF
    
    print_success "Backup created at: $backup_path"
    
    # Clean up old backups
    cleanup_old_backups
}

# Restore from backup
restore_backup() {
    local backup_name="$1"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    if [[ ! -d "$backup_path" ]]; then
        print_error "Backup not found: $backup_name"
        list_backups
        return 1
    fi
    
    print_status "Restoring from backup: $backup_name"
    
    # Show backup info if available
    if [[ -f "$backup_path/BACKUP_INFO" ]]; then
        print_status "Backup information:"
        cat "$backup_path/BACKUP_INFO"
        echo
    fi
    
    # Confirm restore
    print_warning "This will overwrite your current configurations!"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_status "Restore cancelled"
        return 0
    fi
    
    # Create a backup of current state before restore
    create_backup "pre_restore_$TIMESTAMP"
    
    # Restore files
    find "$backup_path" -type f -not -name "BACKUP_INFO" | while read -r backup_file; do
        local relative_path="${backup_file#$backup_path/}"
        local target_file="$HOME/$relative_path"
        
        # Create parent directory
        mkdir -p "$(dirname "$target_file")"
        
        # Copy file back
        cp "$backup_file" "$target_file"
        print_success "Restored: $relative_path"
    done
    
    # Restore directories
    find "$backup_path" -type d -not -path "$backup_path" | while read -r backup_dir; do
        local relative_path="${backup_dir#$backup_path/}"
        local target_dir="$HOME/$relative_path"
        
        if [[ ! -d "$target_dir" ]]; then
            mkdir -p "$target_dir"
            print_success "Created directory: $relative_path"
        fi
    done
    
    print_success "Restore completed from: $backup_name"
    print_status "A backup of your previous state was saved as: pre_restore_$TIMESTAMP"
}

# List available backups
list_backups() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        print_warning "No backups directory found"
        return 0
    fi
    
    print_status "Available backups:"
    
    local backups=()
    while IFS= read -r -d '' backup; do
        backups+=("$(basename "$backup")")
    done < <(find "$BACKUP_DIR" -maxdepth 1 -type d -not -path "$BACKUP_DIR" -print0 | sort -z)
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        print_warning "No backups found"
        return 0
    fi
    
    printf "%-20s %-15s %-10s %s\n" "NAME" "DATE" "SIZE" "INFO"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    for backup in "${backups[@]}"; do
        local backup_path="$BACKUP_DIR/$backup"
        local size
        local info=""
        local date=""
        
        # Get size
        if command_exists du; then
            size=$(du -sh "$backup_path" 2>/dev/null | cut -f1)
        else
            size="unknown"
        fi
        
        # Extract date from backup name if it's a timestamp
        if [[ "$backup" =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
            date="${backup:0:4}-${backup:4:2}-${backup:6:2}"
        else
            date=$(stat -c %y "$backup_path" 2>/dev/null | cut -d' ' -f1 || echo "unknown")
        fi
        
        # Get additional info from BACKUP_INFO
        if [[ -f "$backup_path/BACKUP_INFO" ]]; then
            info=$(head -n 1 "$backup_path/BACKUP_INFO" | cut -d':' -f2- | xargs)
        fi
        
        printf "%-20s %-15s %-10s %s\n" "$backup" "$date" "$size" "${info:0:30}"
    done
}

# Delete a backup
delete_backup() {
    local backup_name="$1"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    if [[ ! -d "$backup_path" ]]; then
        print_error "Backup not found: $backup_name"
        return 1
    fi
    
    print_warning "This will permanently delete the backup: $backup_name"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_status "Deletion cancelled"
        return 0
    fi
    
    rm -rf "$backup_path"
    print_success "Deleted backup: $backup_name"
}

# Clean up old backups
cleanup_old_backups() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        return 0
    fi
    
    local backup_count
    backup_count=$(find "$BACKUP_DIR" -maxdepth 1 -type d -not -path "$BACKUP_DIR" | wc -l)
    
    if [[ $backup_count -gt $MAX_BACKUPS ]]; then
        print_status "Cleaning up old backups (keeping $MAX_BACKUPS most recent)..."
        
        # Get oldest backups to delete
        local to_delete
        to_delete=$(find "$BACKUP_DIR" -maxdepth 1 -type d -not -path "$BACKUP_DIR" -printf '%T+ %p\n' | \
                   sort | head -n $((backup_count - MAX_BACKUPS)) | cut -d' ' -f2-)
        
        while IFS= read -r backup_path; do
            if [[ -n "$backup_path" ]]; then
                local backup_name
                backup_name=$(basename "$backup_path")
                rm -rf "$backup_path"
                print_success "Removed old backup: $backup_name"
            fi
        done <<< "$to_delete"
    fi
}

# Show backup details
show_backup() {
    local backup_name="$1"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    if [[ ! -d "$backup_path" ]]; then
        print_error "Backup not found: $backup_name"
        return 1
    fi
    
    print_status "Backup details: $backup_name"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    # Show backup info
    if [[ -f "$backup_path/BACKUP_INFO" ]]; then
        cat "$backup_path/BACKUP_INFO"
        echo
    fi
    
    # Show backup contents
    print_status "Backup contents:"
    find "$backup_path" -type f -not -name "BACKUP_INFO" | \
        sed "s|^$backup_path/||" | sort
    
    # Show backup size
    if command_exists du; then
        echo
        print_status "Backup size: $(du -sh "$backup_path" | cut -f1)"
    fi
}

# Command dispatch
case "${1:-help}" in
    "create"|"backup")
        create_backup "${2:-}"
        ;;
    "restore")
        if [[ -z "${2:-}" ]]; then
            print_error "Please specify a backup name to restore"
            list_backups
            exit 1
        fi
        restore_backup "$2"
        ;;
    "list"|"ls")
        list_backups
        ;;
    "delete"|"rm")
        if [[ -z "${2:-}" ]]; then
            print_error "Please specify a backup name to delete"
            list_backups
            exit 1
        fi
        delete_backup "$2"
        ;;
    "show"|"info")
        if [[ -z "${2:-}" ]]; then
            print_error "Please specify a backup name to show"
            list_backups
            exit 1
        fi
        show_backup "$2"
        ;;
    "cleanup")
        cleanup_old_backups
        ;;
    "help"|"--help"|"-h")
        echo "Dotfiles Backup and Restore Tool"
        echo ""
        echo "Usage: backup-dots <command> [options]"
        echo ""
        echo "Commands:"
        echo "  create [name]      Create a new backup"
        echo "  restore <name>     Restore from backup"
        echo "  list               List available backups"
        echo "  show <name>        Show backup details"
        echo "  delete <name>      Delete a backup"
        echo "  cleanup            Clean up old backups"
        echo "  help               Show this help"
        echo ""
        echo "Examples:"
        echo "  backup-dots create                    # Create backup with timestamp"
        echo "  backup-dots create pre-update         # Create named backup"
        echo "  backup-dots restore 20231201_120000   # Restore specific backup"
        echo "  backup-dots list                      # List all backups"
        ;;
    *)
        print_error "Unknown command: $1"
        print_status "Use 'backup-dots help' for usage information"
        exit 1
        ;;
esac